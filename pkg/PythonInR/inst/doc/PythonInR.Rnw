\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
%%\usepackage[usenames, dvipsnames]{color}
\usepackage[colorlinks=true, citecolor=blue, linkcolor=red, urlcolor=red]{hyperref}
\usepackage[round]{natbib}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{a4wide}
\usepackage{multirow}
\usepackage{Sweave}
\usepackage{listings}

\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\func}[1]{\mbox{\texttt{#1()}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{\textbf{#1}}
\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\set}[1]{\mathcal{#1}}

\definecolor{darkgray}{gray}{0.3} 
\definecolor{darkgreen}{cmyk}{0.34,0.0,0.69,0.56} 
\definecolor{darkred}{cmyk}{0.0,0.65,0.92,0.31} 
\definecolor{marille}{cmyk}{0.0,0.4,0.67,0.0} 
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}

\newcommand{\comment}[1]{ { \small \begin{quote} \textcolor{darkred}{COMMENT:} \textcolor{darkgray}{#1} \end{quote} } }
\newcommand{\todo}[1]{ { \small \begin{quote} \textcolor{darkred}{TODO:} \textcolor{darkgreen}{#1} \end{quote} } }

\newcommand{\strikeout}[1]{ { \footnotesize \textcolor{darkred}{STRIKEOUT: #1} } }

\setlength{\parindent}{0pt}

\author{Florian Schwendinger}
\title{\pkg{PythonInR}}

\begin{document}

<<echo=FALSE, results = hide>>=
options(width = 75)
set.seed(1)
@


\maketitle
\sloppy

\begin{abstract}
  PythonInR
\end{abstract}

\medskip
\noindent \textbf{Keywords:} \proglang{R}, \proglang{Python}

\section{Installation}
For informations about the installation see the README file.
\section{Introduction}
<<basics, echo=TRUE>>=
library("PythonInR")
@

\section{Basic Usage}
\subsection{Create a Connection}

\subsection{Execute Python Code}
\pkg{PythonInR} offers four different functions for executing 
\proglang{Python} code.
\begin{enumerate}
	\item \code{pyExec} to execute multiple lines of code.
	\item \code{pyExecg} to execute multiple lines of code and retrieve the created variables to \proglang{R}.
	\item \code{pyExecp} to execute a single line of code .
	\item \code{pyGet} to execute a single line a of code and retrieve the created variables to \proglang{R}.
\end{enumerate}

\subsection{Set Python Objects}

\subsection{Get Python Objects}

\subsection{Create Bindings}

\subsection{Other Functions}

\subsection{Options}

\section{Use Cases}
This use case section is mainly based on scripts I used over the years
for various tasks. 
\subsection{Data Import/Export}
For some of the tasks there also exist packages in \proglang{R} but
they were not applicable since they segaulted or run out of memory since I 
was working with messy not that small data.

\subsubsection{Spreadsheet Import/Export}

\paragraph{Export}
<<export_spreadsheet>>=
pyImport(import="Workbook", from="openpyxl")
wb <- Workbook()
ws <- wb$get_active_sheet()
ws$title <- "cars"
## write append the first 10 rows to the workbook
ws$append(colnames(cars))
for (i in seq(1, 10)) {
    ws$append(as.matrix(cars[i,]))
}
ws$append(c('=SUM(A3:A10)', '=SUM(A3:A10)'))
wb$save(th.string("cars.xlsx"))
@

\paragraph{Import}
<<import_spreadsheet>>=
pyImport(import="load_workbook", from="openpyxl")
wb <- load_workbook("cars.xlsx")
wb$get_sheet_names()
ws <- wb$get_sheet_by_name("cars")
pyExec("
def get_range(ws, first_row, first_col, last_row, last_col):
    x = []
    for m in range(first_row, last_row):
        row = []
        for n in range(first_col, last_col):
            row.append(ws.cell(row = m, column = n).value)
        x.append(row)
    return x
")
do.call(rbind, pyCall("get_range", list(ws, 1L, 1L, 10L, 3L), simplify=FALSE))
@

\subsubsection{PDF Import}
Importing \verb+.pdf+ files is often a tedious task, especially if one tries
to import tables. \proglang{R} provides several tools 
(tm, Rpoppler, Rcampdf, pdftables, pdftools) for importing 
\verb+.pdf+ files, also some pdf-viewer allow to export the content into various 
formats and there exists even software specialized to the task of extracting tables
from pdf. However the specialized software normally focuses on automatic 
extraction and it's not possible to provide additional information if the
automatic extraction fails. The \pkg{pdfminer} provides another approach if
the other methods fail it uses the Python package 
\href{http://www.unixuser.org/~euske/python/pdfminer/index.html}{PDFMiner} to 
extract 
<<read_pdf, eval=FALSE>>=
library("pdfminer")
download.file("http://www.fse.provincia.tn.it/binary/pat_fse/beneficiari_FSE/elenco_beneficiari_FSE_PAT_al_30_06_2014.1415269977.pdf", "tmp.pdf")
## get the first 2 pages
x <- read.pdf.base("tmp.pdf", 1:2)
length(x)
head(x[[1]])
@

<<plot_intervalls>>=
font <- "ABCDEE+Calibri"
## pdfminer:::view_intervals(x[[1]], 0.1, offset=99999, font, 500, 50)
@

\subsubsection{Detecting Encodings}


\subsection{Optimization}
\pkg{CVXOPT} \citep{andersen2016cvxopt} is a popular \proglang{Python} package 
for optimization, which is distributed under \verb+GPL-3+. The following example 
shows how to solve an linear programming problem based on the example provided in the 
\href{https://cran.r-project.org/web/packages/Rglpk/index.html}{Rglpk} \citep{pkg:Rglpk} package.
\begin{verbatim}
## Simple linear program.
## maximize:   2 x_1 + 4 x_2 + 3 x_3
## subject to: 3 x_1 + 4 x_2 + 2 x_3 <= 60
##             2 x_1 +   x_2 + 2 x_3 <= 40
##               x_1 + 3 x_2 + 2 x_3 <= 80
##               x_1, x_2, x_3 are non-negative real numbers
\end{verbatim}
There are various options how to solve this problem with \pkg{PythonInR}
<<cvxopt>>=
pyImport(import="solvers", from="cvxopt")
obj <- matrix(-c(2, 4, 3))
mat <- rbind(matrix(c(3, 2, 1, 4, 1, 3, 2, 2, 2), nrow = 3), -diag(3))
rhs <- matrix(c(60, 40, 80, 0, 0, 0))
sol <- solvers$lp(th.cvxopt(obj), th.cvxopt(mat), th.cvxopt(rhs))
sol$x
class(sol$x) ## an R matrix!
## or
sol <- pyCall("solvers.lp", list(th.cvxopt(obj), th.cvxopt(mat), th.cvxopt(rhs)))
sol$x
@
More information about \pkg{CVXOPT} and examples can be found at 
\href{http://cvxopt.org/}{cvxopt} an \proglang{R} binding for \pkg{ROI} is
currently under development 
\href{http://r-forge.r-project.org/R/?group_id=308}{R-Forge ROI.plugin.cvxopt} 
and should be soon (or already are) available at \verb+CRAN+.

\bibliographystyle{plainnat}
\bibliography{PythonInR}

\appendix

\end{document}
